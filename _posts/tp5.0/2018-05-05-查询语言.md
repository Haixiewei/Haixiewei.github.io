---
layout: post
title: "查询语言"
date: 2018-05-05
tag: thinkPHP5
---

`查询内容均配置了数据表前缀 think_ ， 因此统一使用 Db 类的 name 方法代替 table 方法进行举例说明`

### 一、查询表达式

最普通的查询就是判断某个字段是否等于某个值， 例如， 我们查询 think_data 数据表中 id 等于1的数
据， 用法如下：

```
<?php
namespace app\index\controller;
use think\Db;
class Index
{
  public function res1()
  {
    $result = Db::name('data')
        ->where('id',1)
        ->find();
    dump($result);
  }
}

注意， 如果没有使用 use 引入 Db 类的话 需要使用：

$result = \think\Db::name('data')
    ->where('id', 1)
    ->find();
dump($result);
```

提示：
find 方法用于查找满足条件第一个记录（ 即使你的查询条件有多个符合的数据） ， 如果查询成功， 返回的是一个一维数组， 没有满足条件的话则默认返回 null （ 也支持设置是否抛出异常）

生成的SQL语句是：
`SELECT * FROM `think_data` WHERE `id` = 1`

上述的查询其实等同于：

```
$result = Db:name('data')
    ->where('id','=',1)
    ->find();
dump($result);
```

使用表达式查询的时候， where方法的参数依次为：
`where( 字段名， 条件表达式， 查询值 )`

可以支持的查询表达式包括如下：

```
表达式 含义

EQ、=            等于  （ = ）
NEQ、            不等于  （ ）
GT、>            大于  （ > ）
EGT、>=          大于等于  （ >= ）
LT、<            小于  （ < ）
ELT、<=          小于等于  （ <= ）
LIKE             模糊查询
[NOT] BETWEEN   （ 不在 ） 区间查询
[NOT] IN        （ 不在 ） IN 查询
[NOT] NULL       查询字段是否（ 不 ） 是NULL
[NOT] EXISTS     EXISTS查询
EXP              表达式查询，支持SQL语法

其中条件表达式不区分大小写
```

下面就来查询 id 大于等于1的数据， 使用如下代码：

```
$result = Db::name('data')
    ->where('id','>=',1)
    ->limit(10)
    ->select();
dump($result);
```

因为这里需要返回多条记录， 因此这里我们使用了 select 方法， 并且使用 limit 方法限制了返回的最多记录数

提示：
select 方法用于查询数据集， 如果查询成功， 返回的是一个二维数组， 如果没有满足条件的话则返回空
数组（ 也支持设置是否需要抛出异常 ）

生成的SQL语句是：
```SELECT * FROM `think_data` WHERE `id` >= 1 LIMIT 10```

如果使用EXP条件表达式的话， 表示后面是原生的SQL语句表达式， 例如上面的查询可以改成

```
$result = Db::name('data')
    ->where('id','exp','>=1')
    ->limit(10)
    ->select()
dump($result);

生成的SQL语句和前面是一样的
```

如果要查询id的范围， 可以使用

```
$result = Db::name('data')
    ->where('id','in',[1,2,3])
    ->select();
dump($result);

select * from `think_data` where 'id' in (1,2,3)
```

然后id在5到10之间

```
$result = Db::name('data')
    ->where('id','between',[5,10])
    ->select();
dump($result);

select * from `think_data` where `id` between 5 and 10
```

接下来， 使用多个字段查询 id 在 1到3之间的 name 中包含think

```
$result = Db::name('data')
    ->where('id','between',[1,3])
    ->where('name','like','%think%')
    ->select();
dump($result);

select * from `think_data` where `id` between 1 and 3 and `name` like  `%think%`
```

如果要查询某个字段是否为 NULL ， 可以使用

```
$result = Db::name('data')
    ->where('name','NULL')
    ->select();
dump($result);

select * from `think_data` where `name` is null
```

### 二、批量查询

我们可以使用`一个方法完成多个查询条件`， 例如上面的查询可以改成

```
$result = Db::name('data')
    ->where([
          'id' => ['between','1,3'],
          'name' => ['like','%think%'],
      ])->select();
dump($result);

select * from `think_data` where `id` between '1' and '3' and `name` like '%think%'
```

我们再来看一些复杂的用法， 使用 OR 和 AND 混合条件查询， 例如

```
$result = Db::name('data')
    ->where('name','like','%think%')
    ->where('id',['in',[1,2,3]],['between','5,8'],'or')
    ->limit(10)
    ->select();
dump($result);

或者使用  批量方式

$result = Db::name('data')
    ->where([
          'name' => ['like','%think%'],
          'id' => [['in',[1,2,3]],['between','5,8'],'or'],
      ])->limit(10)->select();
dump($result);

select * from `think_data` where ( `id` in (1,2,3) or `id` between '5' and '8' ) and `name` like '%think%' limit 10
```

### 三、快捷查询

如果你有多个字段需要`使用相同的查询条件`， 可以使用快捷查询

例如， 我们要查询id和status都大于0的数据， 可以使用

```
$result = Db::name('data')
    ->where('id&status','>',0)
    ->limit(10)
    ->select();
dump($result);

select * from  `think_data` where ( `id`>0 and `status`>0 ) limit 10
```

也可以使用or方式查询， 例如

```
$result = Db::name('data')
    ->where('id|status','>',0)
    ->limit(10)
    ->select();
dump($result);

select * from `think_data` where ( `id`>0 or `status`>0 ) limit 10
```

### 四、视图查询

如果需要`快捷查询多个表的数据`， 可以使用`视图查询`， 相当于在 数据库 创建了一个视图， 但仅仅支持查询操作

```
$result = Db::view('user','id,name,status')
    ->view('profile',['name'=>'truename','phone','email'],'profile.user_id=user.id')
    ->where('status',1)
    ->order('id','desc')
    ->select();

select user.id,user.name,user.status,profile.name as truename,prefile.phone,profile.email
from think_user user inner join think_profile profile on profile.user_id=user.id
where user.status = 1 order by user.id desc
```

### 五、闭包查询

find 和 select 方法可以直接使用`闭包查询`

```
$result = Db::name('data')
    ->select(function ($query) {
          $query->where('name','like','%think%')
          -     ->where('id','in','1,2,3')
                ->limit(10);
      });
dump($result);

select * from `think_data` where `name` like '%think%' and `id` in ('1','2','3') limit 10
```

### 六、使用Query对象

也可以`事先封装Query对象， 并传入select方法`

```
$query = new \think\db\Query;
$query->name('city')
    ->where('name','like','%think%')
    ->where('id','in','1,2,3')
    ->limit(10);
$result = Db::select($query);
```

使用 Query 对象的话， select 方法之前调用的任何的链式操作都是无效

### 七、获取数值

如果仅仅是需要`获取某行表的某个值`， 可以使用 value 方法

```
// 获取id为8的data数据的name字段值
$name = Db::name('data')
    ->where('id', 8)
    ->value('name');

dump($name);
name的结果为： thinkphp
```

### 八、获取列数据

也支持`获取某个列的数据`， 使用 `column` 方法

```
// 获取data表的name列
$list = Db::name('data')
  ->where('status', 1)
  ->column('name');
dump($list);

返回的结果类似下面：
array (size=5)
0 => string 'thinkphp'
1 => string 'onethink'
2 => string 'topthink'
3 => string 'kancloud'
```

如果希望返回以id为索引的name列数据， 可以改成

```
// 获取data表的name列 并且以id为索引
$list = Db::name('data')
  ->where('status', 1)
  ->column('name', 'id');
dump($list);

返回的结果类似下面：
array (size=5)
1 => string 'thinkphp'
2 => string 'onethink'
3 => string 'topthink'
4 => string 'kancloud'
```

如果需要返回以主键为索引的数据集， 可以使用

```
// 获取data表的name列 并且以id为索引
$list = Db::name('data')
  ->where('status', 1)
  ->column('*', 'id');
dump($list);

返回的结果类似下面：
array (size=5)
    1 => array (size=3)
      'id' => int 1
      'name' => string 'thinkphp'
      'status'=> int 1
    2 => array (size=3)
      'id' => int 1
      'name' => string 'onethink'
      'status'=> int 1
    3 => array (size=3)
      'id' => int 1
      'name' => string 'topthink'
      'status'=> int 1
    4 => array (size=3)
      'id' => int 1
      'name' => string 'kancloud'
      'status'=> int 1
```

### 九、聚合查询

thinkphp为`聚合查询`提供了更便捷的方法

```
// 统计data表的数据
$count = Db::name('user')
    ->where('status',1)
    ->count();

// 统计user表的最高分
$max = Db::name('user')
    ->where('status',1)
    ->max('score');
支持的聚合查询方法包括： 方法 说明 参数

  count   统计数量 统计的字段名（可选）
  max     获取最大值 统计的字段名（必须）
  min     获取最小值 统计的字段名（必须）
  avg     获取平均值 统计的字段名（必须）
  sum     获取总分 统计的字段名（必须）
```

### 十、字符串查询

在必要的时候， 仍然可以使用原生的字符串查询， 但建议是配合参数绑定一起使用， 可以避免注入问题

```
$result = Db::name('data')
    ->where('id > :id and name is not null',['id' => 10])
    ->select();
```

可以直接在 where 方法中使用`字符串 查询条件`， 并`支持第二个参数传入 参数绑定`， 上面这个查询生成的SQL语句是：

```SELECT * FROM `think_data` WHERE ( id > '10' AND name IS NOT NULL )```

### 十一、时间（ 日期） 查询

首先需要在 think_data 数据表新增 create_time 字段， 用于日期查询的字段类型推荐使用
datetime 类型

ThinkPHP5.0 的查询语言强化了对时间日期查询的支持， 例如

```
// 查询创建时间大于2018-1-1的数据
$result = Db::name('data')
      ->whereTime('create_time','>','2018-1-1')
      ->select();
dump($result);

// 查询本周添加的数据
$result = Db::name('data')
    ->whereTime('create_time','>','this week')
    select();
dump($result);

// 查询最近两天添加的数据
$result = Db::name('data')
    ->whereTime('create_time','>','-2 days')
    ->select();
dump($result);

// 查询创建时间在2018-1-1~2018-7-1的数据
$result = Db::name('data')
    ->whereTime('create_time','between',['2018-1-1','2018-7-1'])
    ->select();
dump($result);
```

*日期查询对 create_time 字段类型没有要求， 可以是 `int/string/timestamp/datetime/date` 中的任何一种， 系统会自动识别进行处理*

还可以使用下面的 **人性化日期查询方式**， 例如

```
// 获取今天的数据
$result = Db::name('data')
    ->whereTime('create_time','today')
    ->select();
dump($result);

// 获取昨天的数据
$result = Db::name('data')
    ->whereTime('create_time','yesterday')
    ->select();
dump($result);

// 获取本周的数据
$result = Db::name('data')
    ->whereTime('create_time','week')
    ->select();
dump($result);

// 获取上周的数据
$result = Db::name('data')
    ->whereTime('create_time','last week')
    ->select();
dump($result);
```

### 十二、分块查询

分块查询是为  `查询大量数据的需要`  而设计的

假如 think_data 表已经有超过1万条记录， 但是一次性取那么大的数据会导致`内存开销`非常之大， 但确实又有这个需要（ 例如查询所有的数据并导出到 excel ） ， 采用分块查询可以缓解这个问题

使用分块查询， 可以把 `1万条记录分成 100 次处理， 每次处理 100 条记录`， 代码示例如下

```
    Db::name('data')
        ->where('status','>',0)
        ->chunk(100,function ($list){
              foreach($list as $value){
                // 处理这100条记录
              }
          });

第二个参数可以是有效的 callback 类型， 包括使用闭包函数
```

系统会按照主键顺序查询， 每次查询 100 条， 如果你不希望使用主键进行查询， 或者没有主键的话， 则需要
指定查询的排序字段（ 但必须是唯一的） ， 例如

```
    Db::name('user')
        ->where('status','>',0)
        ->chunk(100,function ($list){
              foreach($list as $data){
                  // 处理100条记录
              }
          },'uid');

然后交给 callback 进行数据处理， 处理完毕后继续查询下一个 100 条记录
```

如果你需要在中途中断后续的查询， 只需要在 callback 方法调用中返回 false 即可， 例如

```
    Db::name('data')
        ->where('status','>',0)
        ->chunk(100,function ($list){
              foreach($list as $data){
                  // 返回false则中断后续查询
                  return false;
              }
          });

```
