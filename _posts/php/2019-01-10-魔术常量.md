---
layout: post
title: "魔术常量"
date: 2019-01-10
tag:
---

```
__LINE__
文件中的当前行号

__FILE__
文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名

__DIR__
文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录
等价于 dirname(__FILE__)。除非是根目录，否则目录中名不包括末尾的斜杠。（PHP 5.3.0中新增）

__FUNCTION__
函数名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。

__CLASS__
类的名称

__METHOD__
类的方法名

__NAMESPACE__
当前命名空间的名称（区分大小写）。此常量是在编译时定义的（PHP 5.3.0 新增）。

__TRAIT__
Trait 的名字（PHP 5.4.0 新加）。自 PHP 5.4.0 起，PHP 实现了代码复用的一个方法，称为 traits。

```

1、php中的trait是what?

    看上去既像类又像接口，其实都不是，Trait可以看做类的部分实现，可以混入一个或多个现有的PHP类中，其作用有两个：表明类可以做什么；提供模块化实现。Trait是一种代码复用技术，为PHP的单继承限制提供了一套灵活的代码复用机制。

2、PHP版本要求：

    php5.4开始引入trait,其目的就是在于减少代码的重复，增加代码的复用性。

3、trait的使用场景：

    试想这样一种情况，当有一个方法需要在很多的类中使用时，该怎么处理？
通常一般的处理方式会是，写一个基础类，在基类中实现这个方法，然后所有类都继承这个基类。

这是一种处理方法，但不是最好的处理方式。通常采用继承的情况是：几个类具有很大的相似性。比如人作为一个基类，学生、工人、等继承“人”这个基类来扩展。

由此，trait的作用就出来了，trait 可以在多个类中使用。

4、trait如何使用：

    1.先声明一个trait
    2.在类中使用use将该trait引入
    3.Trait不能实例化

5、trait的优先级

    从基类继承的成员会被 trait 插入的成员所覆盖。优先顺序是来自当前类的成员覆盖了 trait 的方法，而 trait 则覆盖了被继承的方法。

    优先级：自身方法>trait的方法>继承的方法

总结：Trait是一种代码复用技术，为PHP的单继承限制提供了一套灵活的代码复用机制

打破单继承

```
<?php
trait Dog{
    public $name="dog";
    public function bark(){
        echo "This is dog";
    }
}
class Animal{
    public function eat(){
        echo "This is animal eat";
    }
}
class Cat extends Animal{
    use Dog;
    public function drive(){
        echo "This is cat drive";
    }
}
$cat = new Cat();
$cat->drive();
echo "<br/>";
$cat->eat();
echo "<br/>";
$cat->bark();

输出：
This is cat drive
This is animal eat
This is dog
```

>Trait中的方法或属性会覆盖 基类中的同名的方法或属性，而本类会覆盖Trait中同名的属性或方法

```
<?php
trait Dog{
    public $name="dog";
    public function drive(){
        echo "This is dog drive";
    }
    public function eat(){
        echo "This is dog eat";
    }
}

class Animal{
    public function drive(){
        echo "This is animal drive";
    }
    public function eat(){
        echo "This is animal eat";
    }
}

class Cat extends Animal{
    use Dog;
    public function drive(){
        echo "This is cat drive";
    }
}
$cat = new Cat();
$cat->drive();
echo "<br/>";
$cat->eat();

输出：
This is cat drive
This is dog eat
```


```
<?php
class Base {
    public function sayHello() {
        echo 'Hello ';
    }
}

trait SayWorld {
    public function sayHello() {
        parent::sayHello();
        echo 'World!';
    }
}

class MyHelloWorld extends Base {
    use SayWorld;
}

$o = new MyHelloWorld();
$o->sayHello();

输出：
Hello World!
```

>一个类可以组合多个Trait，通过逗号相隔

当不同的trait中，却有着同名的方法或属性，会产生冲突，可以使用insteadof或 as进行解决，insteadof 是进行替代，而as是给它取别名

如果两个 trait 都插入了一个同名的方法，如果没有明确解决冲突将会产生一个致命错误

为了解决多个 trait 在同一个类中的命名冲突，需要使用 insteadof 操作符来明确指定使用冲突方法中的哪一个

以上方式仅允许排除掉其它方法，as 操作符可以 为某个方法引入别名。 注意，as 操作符不会对方法进行重命名，也不会影响其方法，别名后就不会冲突了...


```
<?php
trait trait1{
    public function eat(){
        echo "This is trait1 eat";
    }
    public function drive(){
        echo "This is trait1 drive";
    }
}
trait trait2{
    public function eat(){
        echo "This is trait2 eat";
    }
    public function drive(){
        echo "This is trait2 drive";
    }
}
class cat{
    use trait1,trait2{
        trait1::eat insteadof trait2;
        trait1::drive insteadof trait2;
    }
}
class dog{
    use trait1,trait2{
        trait1::eat insteadof trait2;
        trait1::drive insteadof trait2;
        trait2::eat as eaten;
        trait2::drive as driven;
    }
}
  $cat = new cat();
  $cat->eat();
  echo "<br/>";
  $cat->drive();
  echo "<br/>";
  echo "<br/>";
  echo "<br/>";

  $dog = new dog();
  $dog->eat();
  echo "<br/>";
  $dog->drive();
  echo "<br/>";
  $dog->eaten();
  echo "<br/>";
  $dog->driven();

输出：
This is trait1 eat
This is trait1 drive



This is trait1 eat
This is trait1 drive
This is trait2 eat
This is trait2 drive
```

>as 还可以修改方法的访问控制

```
<?php
trait Animal{
    public function eat(){
        echo "This is Animal eat";
    }
}

class Dog{
    use Animal{
        eat as protected;
    }
}
class Cat{
    use Animal{
        Animal::eat as private eaten;
    }
}
$dog = new Dog();
$dog->eat();//报错，因为已经把eat改成了保护

$cat = new Cat();
$cat->eat();//正常运行，不会修改原先的访问控制
$cat->eaten();//报错，已经改成了私有的访问控制
```

>Trait也可以互相组合，还可以使用抽象方法，静态属性，静态方法等

```
<?php
trait Cat{
    public function eat(){
        echo "This is Cat eat";
    }
}

trait Dog{
    use Cat;
    public function drive(){
        echo "This is Dog drive";
    }
    abstract public function getName();

    public function test(){
        static $num=0;
        $num++;
        echo $num;
    }

    public static function say(){
        echo "This is Dog say";
    }
}
class animal{
    use Dog;
    public function getName(){
        echo "This is animal name";
    }
}

$animal = new animal();
$animal->getName();
echo "<br/>";
$animal->eat();
echo "<br/>";
$animal->drive();
echo "<br/>";
$animal::say();
echo "<br/>";
$animal->test();
echo "<br/>";
$animal->test();

输出：
This is animal name
This is Cat eat
This is Dog drive
This is Dog say
1
2
```

>从 trait 来组成 trait

正如 class 能够使用 trait 一样，其它 trait 也能够使用 trait。在 trait 定义时通过使用一个或多个 trait，能够组合其它 trait 中的部分或全部成员

```
<?php
trait Hello {
    public function sayHello() {
        echo 'Hello ';
    }
}

trait World {
    public function sayWorld() {
        echo 'World!';
    }
}

trait HelloWorld {
    use Hello, World;
}

class MyHelloWorld {
    use HelloWorld;
}

$o = new MyHelloWorld();
$o->sayHello();
$o->sayWorld();

输出：
Hello World!
```
