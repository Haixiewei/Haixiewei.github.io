---
layout: post
title: "魔术方法"
date: 2019-01-11
tag:
---

<p style="color:red">所有的重载方法都必须被声明为 public <br>(不存在或者protected/private)</p>

`属性重载`

<p style="color:red">
给不可访问属性 赋值 `__set()` 被调用<br>
读取不可访问属性值  `__get()` 被调用</p>

```
get :
mixed __get(string $name)
外部查看一个不存在属性时,会提示该属性不存在
而查看不可见属性时则提示属性不可访问受保护属性,所以如果想在外部访问不可见属性时

set:
void __set(string $name ,mixed $value)
set已存在不可见属性时,就会调用class内部方法,从而可以忽视protected或者private权限
如果想禁止外部set不存在属性,则只需要在class内部声明一个空的public function __set($a,$b){}
即可以禁止外部添加不存在属性
```

```
<?php
class Test
{
  public $c = 0;
  public $arr = array();
  public function __set($x,$y)
  {
    echo $x.'<br/>';
    echo $y.'<br/>';
    $this->arr[$x] = $y;
  }
  public function __get($x);
  {
    echo "the value of $x is".$this->arr[$x];
  }
}

$a = new Test;
$a -> b = 1;    // 成员变量b不存在，所以会调用__set
$a -> c = 2;    // 成员变量c存在，所以无任何输出
$d = $a -> b;   // 成员变量b不存在，所以会调用__get, 这就是读取

输出：
b
1
the value of b is 1
```

-------

<p style="color:red">
对不可访问属性调用isset()或empty()  `__isset()` 被调用<br></p>

```
isset不可见或不存在属性时,预运行该方法
当没有设置该方法或者设置为空时,外部isset不可见属性或者不存在属性都将返回false
class one
{
   protected $name='a';
   public function __isset()
   {
     return ture;
   }
}
$j = new one();
var_dump($j -> name);
var_dump($j -> age);

name存在查询是返回ture,而age实际不存在,也会返回true
与实际不相符,却给你表明了权限问题呢,就是,coder说是真就是真,不是真也是真
做一个诚实的coder吧
public function __isset($x)
{
  return isset($this->$x);
}
如此就可以进行正确的查询
```
<p style="color:red">
对不可访问属性调用unset()    `__unset()` 被调用</p>

```
当不设置__unset时,可以unset掉存在的可见属性,而不可见属性则会提示不能销毁被保护属性
如果你想要unset掉一个保护属性的话,则需要加入如下代码
public function __unset($a)
{
    unset($this->$a);
}
```

isset() 函数用于检测变量是否已设置并且非 NULL

如果已经使用 unset() 释放了一个变量之后，再通过 isset() 判断将返回 FALSE

若使用 isset() 测试一个被设置成 NULL 的变量，将返回 FALSE

同时要注意的是 null 字符（"\0"）并不等同于 PHP 的 NULL 常量

```
如果一次传入多个参数，那么 isset() 只有在全部参数都被设置时返回 TRUE
计算过程从左至右，中途遇到没有设置的变量时就会立即停止

<?php

$var = '';
if (isset($var)) {
    echo "变量已设置" . PHP_EOL;   // 结果为 TRUE，文本将被打印出来
}

$a = "test";
$b = "anothertest";

var_dump(isset($a));      // bool(true)
var_dump(isset($a, $b));  // bool(true)

unset ($a);
var_dump(isset($a));      // bool(false)
var_dump(isset($a, $b));  // bool(false)

$foo = NULL;
var_dump(isset($foo));   // bool(false)

```

----------------

`方法重载`

<p style="color:red">在对象中调用一个不可访问方法时 `__call()` 被调用</p>

```
__call() 方法用于监视错误的方法调用
function __call(string $function_name, array $arguments)
{
    ......
}
```

该方法有两个参数，第一个参数 $function_name 会自动接收不存在的方法名，第二个 $args 则以数组的方式接收不存在方法的多个参数

```
function __call($function_name, $args)
{
    echo "你所调用的函数：$function_name(参数：<br />";
    var_dump($args);
    echo ")不存在！";
}

当调用一个不存在的方法时（如 test() 方法）：

$p1=new Person();
$p1->test(2,"test");

输出：
你所调用的函数：test(参数：
array(2) {
    [0]=>int(2)
    [1]=>string(4) "test"
}
)不存在！
```

<p style="color:red">静态上下文中 调用一个不可访问方法   `__callStatic()` 被调用</p>

```
<?php
class MethodTest
{
    public function __call($name, $arguments)
    {
        // 注意：$name的值区分大小写
        echo "Calling object method '$name' " . implode(', ', $arguments) . "\n";
    }
    // PHP 5.3.0之后的版本
    public static function __callStatic($name, $arguments)
    {
        echo "Calling static method '$name' " . implode(', ', $arguments) . "\n";
    }
}   

$obj = new MethodTest;
$obj -> runTest('in object context');

// PHP 5.3.0 版本以后
MethodTest::runTest('in static context');

Calling object method ‘runTest’ in object context
Calling static method ‘runTest’ in static context

```

更有用的使用方式是在实现MVC框架的时候可以实现链式调用，就像ThinkPHP中经常使用的那样

在这个示例中，我们创建了Strings类，这个类可以构建一个字符串，还包括trim()和strlen()方法

<p style="color:red">使用 `__call()` 方法，我们就可以实现 `$str->trim()->strlen()` 这样的链式操作</p>

```
<?php
class Strings
{
    public $str = '';
    public function __construct($str)
    {
        $this->str = $str;
    }
    public function __call($name, $arguement)
    {
        $ret = '';
        switch ($name)
        {
            case 'trim' :
                $new_s = trim($this->str);
                $ret = new Strings($new_s);
                break;
            case 'strlen' :
                $ret = strlen($this->str);
                break;
            default:
        }
        return $ret;
    }
}

$s = new Strings("   codeman   ");
$length = $s->trim()->strlen();
echo  "删除空格以后的长度为：" . $length;

运行结果：
删除空格以后的长度为：7

```

-------------

<p style='color:red'>public __toString ( void ) : string</p>

一个类被当成字符串时应怎样回应 echo $obj; 应该显示些什么;print

此方法必须返回一个字符串，否则将发出一条 E_RECOVERABLE_ERROR 级别的致命错误

<span style='color:red'>Warning：</span>
不能在 __toString() 方法中抛出异常。这么做会导致致命错误

```
<?php
// Declare a simple class
class TestClass
{
    public $foo;
    public function __construct($foo)
    {
        $this->foo = $foo;
    }
    public function __toString() {
        return $this->foo;
    }
}

$class = new TestClass('Hello');
echo $class;

输出：
Hello
```

-------------

__toString(void) 是把对象当字符串输出后调用

那我要是当成函数调用使用这对象呢（invoke调用的翻译）

<span style='color:red'>__invoke()</span>

```
<?php
class CallableClass
{
  function __invoke($x)
  {
    var_dump($x);
  }
}

$obj = new CallableClass();
$obj(5);
var_dump(is_callable($obj));

int(5)
bool(true)
```

is_callable() 函数用于检测函数在当前环境中是否可调用

--------------------

`对象被当成字符串输出和当作函数调用使用。接着是对象序列化与反序列化中使用`

当序列化 `serialize` 对象时，可以<span style='color:red'>把对象里的属性和方法转换成连续的bytes数据<br>
保存在一个文件里或者在网络上传输</span>，当需要使用这个对象时，就可以反序列话 `unserialize` <br>
这个字符串，得到这个对象，然后继续使用

<span style='color:red'>注意：</span>这两个方法都不接受参数



当对一个对象序列化时，php就会调用 `__sleep` 方法（如果存在的话）<br>
在反序列化时，php就会调用 `__wakeup` 方法（如果存在的话）<br>

`__sleep` 这个方法可以用于清理对象，并返回一个包含对象中所有变量名称的数组

如果该方法不返回任何内容，则NULL被序列化，导致一个E_NOTICE错误

在反序列化unserialize时，会检查是否存在__wakeup方法，如果存在

则会调用__wakeup方法，预先准备对象数据。

`__sleep()` 方法常用于提交未提交的数据，或类似的清理操作<br/>
同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用<br/>
`__wakeup` 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作

```
class user
{
  public $name;
  public $id;
  function __construct()
  {
    $this->id = 123;
  }
  function __sleep()     //此处不串行化id成员
  {
    return(array('name'));
  }
  function __wakeup()
  {
    $this->id = 456;
  }
}

$u = new user();
$u -> name = 'li';

// serialize串行化对象u，此处不串行化id属性，id值被抛弃
$s = serialize($u);
// unserialize反串行化，id值被重新赋值
$u2 = unserialize($s);

print_r($u);
print_r($u2);

user Object ( [name] => li [id] => 123 )
user Object ( [name] => li [id] => 456 )
```

`__sleep`方法常用于提交未提交的数据，或类似的操作
<p style="color:red">`__sleep`方法必须返回一个数组,包含需要串行化的属性. PHP会抛弃其它属性的值. 如果没有__sleep方法,PHP将保存所有属性</p>

来一个重新建立数据库连接

```
<?php
class Connection
{
  protected $link;
  private $server,$username,$password,$db;
  public function __construct($server,$username,$password,$db)
  {
    $this->server = $server;
    $this->username = $uesrname;
    $this->password = $password;
    $this->db = $db;
    $this->connect();
  }
  public function connect()
  {
    $this->link = mysql_connect($this->server,$this->username,$this->password);
    mysql_select_db($this->db,$this->link);
  }
  public function __sleep()
  {
    return array('server','username','password','db');
  }
  public function __wakeup()
  {
    $this->connect();
  }
}
```

在程序执行前，serialize() 函数会首先检查是否存在一个魔术方法` __sleep`.如果存在，`__sleep()`方法会先被调用， 然后才执行串行化（序列化）操作。这个功能可以用于清理对象，并返回一个包含对象中所有变量名称的数组。如果该方法不返回任何内容，则NULL被序列化，导致 一个E_NOTICE错误。与之相反，unserialize()会检查是否存在一个`__wakeup`方法。如果存在，则会先调用` __wakeup`方法，预先准备对象数据。
