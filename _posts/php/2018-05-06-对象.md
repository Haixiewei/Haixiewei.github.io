---
layout: post
title: "面向对象编程oop"
date: 2018-05-06
tag: php
---

*php类的定义*

类是对某个对象的定义。它包含有关对象动作方式的信息，包括它的名称、方法、属性和事件

`实际上它本身并不是对象，因为它不存在于内存中`

当引用类的代码运行时，类的一个新的实例，即对象，就在内存中创建了

虽然只有一个类，但能`从这个类在内存中创建多个相同类型的对象`

注意事项：

1.定义一个类（只能用class定义）

2.定义类的属性public，public是修饰符，共有三个，是public,protected,private

---------------

*php类的实例化方法*

类的实例化又叫创建一个对象或者实例化一个对象或者把类实例化

new翻译是新的，意思就是创建一个新的人，并把这个新的对象赋值给$Preson1，这个就是实例化

如果想输出第二个实例，直接输出就OK了，只要改一个变量名

---------------

*什么是面向对象？*

面向对象编程，也就是我们常说的`OOP`，其实是面向对象的一部分

面向对象一共有3个部分：面向对象分析（OOA）、面向对象设计（OOD）、面向对象编程（OOP）

我们现在将要学习的就是面向对象的编程，而面向对象编程中两个首要了解的也是很重要的概念就是类和对象

类与对象

万物皆对象，世间的万物我们都可以看成是对象，因为他们都有各自的属性

-----------

*面向对象编程三大特性*

(1).封装性

简单形象的解释就是，把功能放在一个盒子里，要用到这个功能的时候，打开盒子，取出就可以使用

(2).继承性

子类自动继承一个或多个父类中的属性与方法，并可以重写或者添加新的属性或方法

这个特性简化了类和对象的创建，提高了代码的可重用性

(3).多态性

指的是一个类可以创建多个对象，获取不同的结果

----

*构造函数*

一种特殊的方法  主要用来在创建对象时初始化对象

即为对象成员变量赋初始值，总与 `new运算符一起使用在创建对象的语句` 中

特别的一个类可以有多个构造函数

可根据其参数个数的不同或参数类型的不同来区分它们 即构造函数的重载

```
先创建一个类，并且初始化这个类

class Preson{
    public $name;                     //定义变量
    public $age;
    public $sex;
    public $height;
}

$Preson1 = new Preson();
$Preson1->$name = "大白";        //变量赋值
$Preson1->$age = 20;
$Preson1->$sex = "女";
$Preson1->$height = 180;
```

可以看到，上述例子中赋值过程比较繁琐，如果变量很多的话，工作量将会非常大，很麻烦

所以，我们引入了构造方法。所以构造函数的作用就是用来初始化对象的

该方法可以没有参数，也可以有多个参数

定义构造函数也很简单，`__construct()`,值得注意的是函数construct前面是两个下划线"_"

```
class Preson{
    public $name;                     //定义变量
    public $age;
    public $sex;
    public $height;

    function __construct($name,$age,$sex,$height){
        $this->name = $name;         //为变量赋值
        $this->age = $age;
        $this->sex = $sex;
        $this->height = $height;
    }

    public function PlayBaskteBall(){
        if($this->height>175 || $this->age < 22){
                return    $this->name . "可以打篮球";
            }else{
                return $this->name . "不具备打球的条件";
            }
        }
}

$Preson1 = new Preson("大白","20","女","180");
echo $Preson1->PlayBaskteBall();
```

构造方法是初始化对象时使用的，如果没有构造方法，那么PHP会自动生成一个。自动生成的构造方法没有任何参数，没有任何操作

-----------

*析构函数*

析构函数的作用和构造函数的作用正好相反，是对象被销毁时被调用，作用是释放内存

定义析构函数的格式为：`__destruct()`,和构造函数一样的是，前面也是两个下划线"_"

```
class Preson{
    public $name;                     //定义变量
    public $age;
    public $sex;
    public $height;
    function __construct($name,$age,$sex,$height){
        $this->name = $name;         //为变量赋值
        $this->age = $age;
        $this->sex = $sex;
        $this->height = $height;
    }

    function __destruct(){
        echo "对象被销毁了";
    }
}

$Preson1 = new Preson("大白","20","女","180");
echo $Preson1->name;

输出：
大白
对象被销毁了
```

php使用的是一种`垃圾回收`机制，自动清除不再使用的对象，释放内存

就是说即使不使用unset函数，析构方法也会自动被调用

这里只是明确一下析构函数在何时被调用。一般情况下是不需要手动穿件析构方法的

--------------

```
class Preson{
   public $name;              //定义成员变量
   public $age;
   public function Run(){     //声明成员方法
      echo "人在塔在";
  }
}
```

类中有变量，那么相对的也就是会有常量。常量的意思就是不会改变的量，是一个恒值

定义常量，我们用`const`

```
<?php
class  character{
    public $name;               //声明一个变量
    const SKILLS = '哈撒尅'；    //声明一个常量
}

$character1 = new character();
$character1->name = "亚索";
echo '我要玩' . $character1->name . '<br/>' . '技能是' . character::SKILLS;
```

**const定义的常量访问使用 类名::const常量名**

-----------

*什么是静态方法？*

不是所有的变量和方法都要通过创建对象来调用

可以通过给变量和方法加上 `static关键字` 来直接调用

调用静态成员的语法格式为：**关键字::静态成员**

关键字可以是：<br/>
（1）self，在类内部调用静态成员时所使用<br/>
（2）静态成员所在的类名，在类外调用类内部的静态成员时所使用<br/>

注意：在静态方法中，`只能调用静态变量`，而不能调用普通变量；而普通方法则可以调用静态变量

```
<?php
class Math{
    static function squared($input){
        return $input*$input
    }
}
echo Math :: squared(3);

9
```

1. 在静态方法中，不能使用$this关键字，因为可能会没有可以引用的对象实例
2. 因为静态方法可以不需要实例化对象

使用静态成员，除了可以不需要实例化对象外<br/>
另一个作用就是在对象被销毁后，仍然保存被修改的静态数据，以便下次继续使用

```
<?php
header("content-type:text/html;charset=utf-8");

class Play{
    static $num = 0;
    function showNum(){
        echo '这是你第' . self :: $num . '次玩LOL';
        self :: $num++ ;
    }
}

$play1 = new Play();
$play1 -> showNum();
echo '<br/>';

$play2 = new Play();
$play2 -> showNum();
echo '<br/>';

echo '这是你第' . Play::$num .'次玩LOL';
```

上述实例中，我们先定义了静态变量$num   然后再类中声明一个方法

在方法当中调用了静态变量，调用的方法可以在实例中看到，接着是给静态变量加1

依次实例化类的对象，再调用方法。接下来就是我们上面说的：在对象被销毁后，仍然保存被修改的静态数据，以便下次继续使用

注意事项：

静态方法很好用，不用实例化对象，当类第一次加载的时候就已经给了静态成员空间

但是什么东西都是不能滥用的。因为一旦静态成员声明的过多，空间一直被占用着，那么会影响系统的运行速度和功能，所以切记：东西虽好，可不能贪多哦！

-------------

*$this->用法简述*

在成员方法中，调用成员方法的方法是对象名加方法名，格式就是“对象名->方法名”

但是在定义类的时候，我们往往不知道对象名是什么，所以就没法用对象名

这时，我们就要用到   伪变量 `$this`

$this的意思就是本身，在$this中有个指针，谁调用它，他就指向谁，它只能再类内部使用

```
<?php
header("content-type:text/html;charset=utf-8");

class Preson{         //定义类
  public $name;
  public $age;
  public function __construct($Name,$Age)   //构造函数
  {
     $this -> name = $Name;
     $this -> age = $Age;
     echo '<pre>';
     var_dump($this);                       //打印出$this
  }
  public function showInfo(){               //成员方法
     echo "个人信息：";
     echo '<br/>' . "名字是：" . $this -> name . '<br/>' . "年龄是：" . $this -> age;
  }
}

$preson = new Preson("小草",25);           //实例化
var_dump($preson);                    //打印出$this
$preson -> showInfo();
echo '<hr>';

$preson = new Preson("大树",30);           //实例化
var_dump($preson);                   //打印出$preson
$preson -> showInfo();
```

打印出来的$this和$preson结果是一样的

也就是说，$preson调用了$this，$this指向的就是它，所以说结果是一样的

因此$this究竟指向哪是由所实例化的对象决定的，指向当前对象实例的指针

包括变量、方法都是如此。也就是印证了我们上面的话谁调用它，他就指向谁

--------------

*数据隐藏*

`public、private、protected、static和final`

这些关键词是用来限定类成员，包括变量和方法的访问权限的

接下来，我们就先讲解前三个关键词的用法

友情提示：
对成员变量和成员方法进行限定在关键字的使用上都是一样的。所以这里我们只以成员变量为例说明这几种关键字的不同用法。对于成员方法同样适用

下面，我们来具体介绍这几个关键词：

（1）public

公共的 就是公开的，不需要隐藏的数据信息

可以在程序中的任何位置（类内、类外）被其他的类和对象调用

子类可以继承和使用父类中所有的公共成员

（2）private

私人的  私有的

被private修饰的变量和方法，`只能在所在的类的内部` 被调用和修改

不可以在类的外部被访问 在子类中也不可以

private实例展示：

```
<?php
header("content-type:text/html;charset=utf-8");
class Preson{
   private $name = "雷克赛";
   public function setName($name){
       $this -> name = $name;
   }
   public function getName(){
       return $this ->name;
   }
}
class Preson1 extends Preson{

}

$preson = new Preson();

//正确的使用方式
echo '我的名字叫';
$preson ->setName("布里茨");    //通过访问成员方法进行赋值
echo $preson -> getName();      //在通过访问成员方法进行访问

//错误的使用方式
echo '我的名字叫';
echo Preson :: $name;

我的名字叫布里茨我的名字叫
Fatal error: Uncaught Error: Cannot access private property Preson::$name in ...
```

上述实例中，对私有变量$name的修改与访问，只能通过调用成员方法来实现。如果直接调用，就会发生错误

（3）protected

保护的意思  

private关键字可以将数据完全隐藏,除了在本类中，别的地方都不可以调用，子类中也不可以

但是有些情况是部分变量需要在子类中可以调用，但是对另外的类来说，还是要做到封装。这个时候就要用到我们的protected关键字了

用protected修饰的类成员，可以在本类和子类中被调用，但是在其他地方不能被调用

protected的实例展示：

```
<?php
header("content-type:text/html;charset=utf-8");
class Preson{
   protected $name = '维克托';
}
class Preson1 extends Preson{
   public function showName(){
       echo '只有真确的调用，我才会出现';
       echo '<br/>';
       echo '我的名字是:' . $this ->name;
       echo '<br/>';
   }
}

$preson = new Preson1();
$preson -> showName();

echo '你调用错了，所以下面不报错算我输：';
$preson -> name = '德莱文';

只有真确的调用，我才会出现
我的名字是:维克托
你调用错了，所以下面不报错算我输：
Fatal error: Uncaught Error: Cannot access protected property Preson1::$name in ...
```

上述实例中，先用关键词protected声明一个变量，然后再子类的方法中调用一次，最后在类外直接调用一次，结果一目了然

提示：

虽然在PHP中没有对修饰变量的关键字做强制性的规定和要求，但从面相对象的特征和设计方面考虑，一般使用private和protected关键字来修饰变量，以防止变量在类外被直接修改和调用

---------------

*类的继承*

说白了，就是提高代码使用效率的

子类继承父类的所有成员变量和方法，包括构造方法，当子类被实例化时，php会现在子类中查询构造方法

如果子类有自己的构造方法，php会先调用子类中的方法<br/>
当子类中没有时，php则去调用父类中的构造方法，这也就是我们说的继承

类的继承是通过关键字 `extends`，语法为：``` class A extends B{...} ```


A代表子类，B代表父类, 首先创建一个类，类中有不同的方法

```
<?php
//父类
    class Lol{
        public $name;
        public $type;
        public $price;
        public function __construct($name,$price){
            $this->name = $name;
            $this->price = $price;
        }
        function ShowInfo(){
            echo  "在这不显示";
        }
    }

//子类Play
    class Play extends Lol{           //定义子类，继承父类
        public $type;                     //在子类中定义变量
        public function __construct($name,$type){
            $this->name = $name;
            $this->type = $type;
        }
        function ShowInfo(){
            if($this->type == "mid"){
                return  $this->name . "会玩这个位置";
            }else{
                return $this->name . "不会玩这个位置";
            }
        }
    }

//实例化对象
$player = new Play("faker","mid");
echo $player->ShowInfo();

faker会玩这个位置
```

-------------


**操作符 “::”**

相比伪变量$this只能在类的内部使用来说更为强大

``操作符“::”可以在没有任何声明任何实例的情况下访问类中的成员方法或成员变量``

使用"::"操作符的通用语法为：`关键字::变量名/常量名/方法名`

注意事项：

这里的关键字不再是public、private、protected或者static等，而是以下三种情况：

（1）parent :可以调用父类中的成员变量、成员方法和常量<br/>
（2）self：可以调用当前类中的静态成员和常量<br/>
（3）类名：可以调用本类中的变量、常量和方法<br/>

```
<?php
header("content-type:text/html;charset=utf-8");
class Hero{                                        //定义类
    const CHARACTER = '奥利安娜';                  //定义常量，用关键字const
    function __construct()                        //父类中的构造函数
    {
        echo '5楼要玩中单' . Hero :: CHARACTER . '不给就送';     //输出常量
        echo '<br/>';
    }
}
class I_Hreo extends Hero{                      //创建子类I_Hreo继承父类
     const ROLE = '亚索';                         //创建常量
     function __construct()                      //子类中创建构造函数
     {
         parent :: __construct();               //引用父类中的构造函数
         echo '4楼中单' . self :: ROLE . '贼6'; //子类中输出
     }
 }

$gamer = new I_Hreo();                             //实例化
```

实例解释：

在上述实例中，我们先创建了一个父类Hero，定义了常量，创建了构造函数，接着又创建了一个子类 I_Hreo去继承父类 Hreo，且在子类中也定义了常量

我们引用父类中的构造函数。上面我们介绍了三种情况，parent :可以调用父类中的成员变量、成员方法和常量。这里我们调用的是父类中的方法，所以使用parent :: __construct()

接着，我们在子类的构造方法中输出子类中定义的常量，调用当前类的关键字，上面也介绍过，self：可以调用当前类中的静态成员和常量，所以这里我们用self :: ROLE，最后格式化，运行一下

```
5楼要玩中单奥丽安娜不给就送
4楼要玩中单亚索贼6
```
