---
layout: post
title: "正则"
date: 2019-04-10
tag: php
---

### 一、定界符

不能用 `a-zA-Z0-9\` 其他的都可以用。必须成对出现，有开始就有结束

`\` 是转义字符

```
/中间写正则/	   正确
$中间写正则$	   正确
%中间写正则%	   正确
^中间写正则^	   正确
@中间写正则@	   正确
(中间写正则)	   错误
A中间写正则A	   错误
```

### 二、原子

原子是正则表达示里面的 `最小单位`，原子说白了就是需要 `匹配的内容`<br/>
一个成立的正则表达示当中`必须最少要有一个原子`

所有可见不可见的字符就是原子<br/>
说明：我们见到的空格、回车、换行、0-9、A-Za-z、中文、标点符号、特殊符号全为原子

`int preg_match ( string $正则 , string $字符串 [, array &$结果] )`

```
<?php
//定义一个变量叫zz，放正则表达示 为了方便记忆，英文比ok，就$pattern
$zz = '/abc/'
$str = 'kjgtktgk' //  没有'abc'匹配
if (preg_match($zz,$str,$matches)){
  echo '匹配ok';
  var_dump($matches);
}else{
  echo 'gg';
}

gg
```

匹配空格试试

```
$zz = '/ /';
$string = 'sssssw aaa aa';
if(preg_match($zz, $string, $matches)){
   echo '匹配ok';
   var_dump($matches);
}else{
   echo 'gg';
}

匹配ok array(1) { [0]=> string(1) " " }
```

### 三、特殊标识的原子

| 原子        | 功能    | 等价|
| --------   | -----:   |  -----:   |
| \d        | 0-9     |  [0-9]
| \D        | 除了 0-9 以外的所有字符      |  [^0-9]
| \w        | a-z A-Z 0-9 _      |[ a-zA-Z0-9_ ] |
| \W        | 除了 a-z A-Z 0-9 _ 以外的所有字符      | [ ^a-zA-Z0-9_ ] |
| \s        | 匹配所有空白字符 \n \t \r 空格     |[ \t\n\f\r ] |
| \S        | 匹配所有非空白字符      |[^ \t\n\f\r ] |
| []        | 指定范围的原子      |




### 四、元字符

| 元字符        | 功能    |
| --------   | -----:   |  
| *        |   是代表匹配前面的一个原子<br>匹配0次或者任意多次前面的字符  |  
| +       |    匹配最少一次前面的一个字符   |
| ？        |   前面的字符可有可无【可选】 有或没有  |  
| .       |    把点算作原子。匹配除了\n以外的所有字符   |
| 竖线     |  或者 优先级最低   |  
| ^       |    必须要以抑扬符之后的字符串开始   |
| $        |  必须要以$之前的字符结尾   |  
| \b       |   词边界    |
| \B        |   非边界  |  
| {m}       |   有且只能出现m次    |
| {n,m}       |  可以出现n到m次   |  
| {m,}      |   至少m次，最大次数不限制    |
| ()       |    改变优先级或者将某个字符串视为一个整体<br>匹配到的数据取出来也可以使用它   |

```
1.正则表达示是有边界的，这个边界是定界符的开始和结尾是正则的边界
2.this是一个英文单词，后面加上一个空格，意味着这个词结束了，到达了这个词的边界
\b词边界，就是指必须要在最前或者最后

<?php
$zz = '/\w+\b/';
$string1 = "this is a apple";
$string2 = "thisis a apple";
$string3 = "thisisaapple";
if (preg_match($zz, $string1, $matches)) {
   echo '匹配ok';
   var_dump($matches);
} else {
   echo 'no';
}

依次匹配string1，2，3
结论：
1.$string1、$string2和$string3都匹配成功
2.$string1匹配的时候this 空格是边界
3.$string2匹配的时候thisis是边界
4.$string3匹配的时候，thisisaapple到了整个正则表达示的最后
  因此也是边界。所以匹配成功
```

```
<?php
$zz = '/\Bthis/';
$string1 = "hellothis9";
$string2 = "hello this9";
$string3 = "this9中国万岁";
if (preg_match($zz, $string1, $matches)) {
   echo '匹配ok';
   var_dump($matches);
} else {
   echo 'no';
}
总结：
1.匹配$string1成功而$string2,3不成功
2.因为\B后接的是this，所以this不能在词边界（空格和开始结尾）的位置出现
```

### 五、模式匹配符

| 模式匹配符        | 功能    |
| --------   | -----:   |  
| i        |   不区分大小写 $pattern = '/ABC/i'; <br> 模式中的字符将同时匹配大小写字母 |  
| m       |    字符串视为多行   |
| s       |   将字符串视为单行,换行符作为普通字符.    |
| x       |    将模式中的空白忽略   |
| A       |   强制仅从目标字符串的开头开始匹配    |
| D       |   模式中的美元元字符仅匹配目标字符串的结尾    |
| U       |    匹配最近的字符串   |

`m 视为多行`

```
<?php
$pattern = '/^a\d+/';
$string = "我的未来在自己手中我需要不断的努力
a9是一个不错的字符表示
怎么办呢，其实需要不断奋进";
if (preg_match($pattern, $string, $matches)) {
    echo '匹配ok';
    var_dump($matches);
} else {
    echo 'no';
}

no

修改  $pattern = '/^a\d+/m';
匹配ok array(1) { [0]=> string(2) "a9" }
```




### 二、原子
