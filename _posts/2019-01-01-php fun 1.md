---
layout: post
title: "php函数简单总结"
date: 2019-01-12
tag: php
---

### 一、PHP的函数基本语法

函数 就是 功能。调用一个函数就是在调用一个功能，函数可以反复调用

函数分为两大类别：`自定义函数` `系统函数`


### 二、自定义函数

```
function 函数名([参数名1[=值1], 参数名2[=值2], 参数名n[=值n]])
{
    函数中的功能体
    [return 返回值]
}
```

语法特点简介

    1.函数以function开始，function后面接空格，空格后接函数名

    2.函数名与变量命名规则基本一样，但不同的是：函数名不区分大小写

    3.参数其实就是变量，函数名后接括号，括号内跟参数，参数全都用[]括起来了，代表参数可填可不填

    4.如果有参数的话，参数后可以接（＝），等号接默认值。参数值也是用[]括起来的，代表选填

    5.函数后的参数变量，主要功能是把函数体外的变量值，传入函数体内来使用，函数体的变量和函数体外的变量通常是两个不同的变量

    6.函数中的具体功能用大括号括起来，代表这是一个函数的功能区间

    7.函数可以有返回值也可以没有返回值，用[]括起来的，代表选填

    8.return后接空格，空格后接返回值，若有return,return后的代码均不执行。

    9.函数的执行没有顺序关系，可以在定义处之前的位置调用

    10.函数不能被定义两次，即函数不能被重载

实验观点

    1.任意位置调用
    2.函数名只能是字母，数字，下划线的组合，并且之间不能包含空格，数字不能放在变量名首位
    3.函数名与变量命名规则一样，但是不同的是：函数名不区分大小写
    4.函数体的参数若是定义了，未传参数，代码会报错，Warning: Missing argument 1 for test()
    5.函数后的参数如果有默认值，参数可以不填，代码也不会报错，函数后的参数可以写多个
    6.函数后如果有默认值和无默认值的参数，通常把 无默认值的参数写在最前面
    7.函数体的变量与函数体外的变量没有关系
    8.函数体中若有return,return 后的代码不执行
    9.函数执行完后,return 可把函数体内的值，带带函数体外
    10.函数的执行没有顺序关系，可以在定义处之前的位置调用
    11.函数不能被重载



### 三、回调函数

回调函数，可以`配合匿名函数和变量函数`实现更加优美、复杂的一种`函数结构`

回调函数，就是在处理一个功能的时候，让这个功能自定义能力再强一些，准许调用这个函数的时候，还可以传入一个函数配合、协助进行处理

```
<?php
function woziji($one,$two,$func){
       // 规定：检查$func是否是函数，如果不是函数停止执行本段代码，返回false
       if(!is_callable($func)){
               return false;
       }
       // is_callable() 验证变量的内容能否作为函数调用

       // $func是一个变量函数
       echo $one + $two + $func($one,$two);
}

function plusx2( $foo , $bar){
       $result = ($foo+$bar)*2
       return $result;
}

function jian( $x , $y ){
   $result = $x - $y;
   return $result;
}

// 调用一下函数，woziji，向里面传入参数试试
echo woziji(20,10,'plusx2');
echo woziji(20,10,'jian');
```

>回调函数：在一个调数里面，再传入一个函数名，将函数名加上()括号，识为变量函数，配合执行

### 四、变量函数

可变函数，也叫变量函数。可以用于以后的MVC，面向对象的设计模式等处

### 五、匿名函数

>1.变量函数式的匿名函数

匿名函数的第一种用法，直接把赋数赋值给变量，调用变量即为调用函数

```
<?php
$greet = function($name)
{
  echo $name.'，你好';
};
$greet('明天');
$greet('PHP');
```

>2.回调式的匿名函数

通过一个函数实现更多的功能。但是，我又不想专门定义一个函数

```
<?php
function woziji($one,$two,$func){
       if(!is_callable($func)){
               return false;
       }
       echo $one + $two + $func($one,$two);
}
woziji(20,30,function( $foo , $bar){
               $result = ($foo+$bar)*2;
               return $result;
           }
);
```

### 六、内部函数

内部函数，是指在函数内部又声明了一个函数

注意事项：

    1.内部函数名，不能是已存在的函数名

    2.假设在函数a里面定义了一个内部函数，不能定用两次函数a

```
<?php
function foo()
{
     echo '函数foo，调一下我才会执行定义函数bar的过程<br />';
     function bar()
     {
          echo '在foo函数内部有个函数叫bar函数<br />';
     }
}

// 现在还不能调用bar()函数，因为它还不存在
// bar();

foo();

// 可以调用bar()函数了，因为foo()函数的执行使得bar()函数变为已定义的函数

bar();

// 再调一次foo()看看是不是会报错？
foo();

输出：
函数foo，调一下我才会执行定义函数bar的过程

在foo函数内部有个函数叫bar函数

函数foo，调一下我才会执行定义函数bar的过程
Fatal error: Cannot redeclare bar()...
[redeclare重新声明，重新定义]
```

### 七、自定义函数之 变量作用域

>函数定义时后括号里面接的变量是形式上的参数（形参），与函数体外的变量没有任何关系。仅仅是在函数内部执行<br>
>函数内声明的变量也与函数外的变量没关系

但是，我们实际的处理情况中会遇到这样的一个情况：

    1.我想在函数体内定义的变量在函数体外用
    2.我想把函数体外的变量拿到函数体内来使用

> 这个时候我们就需要用到超全局变量

$_COOKIE	得到会话控制中cookie传值<br>
$_SESSION	得到会话控制中session的值<br>
$_FILES	得到文件上传的结果<br>
$_GET	得到get传值的结果<br>
$_POST	得到post传值的结果<br>
$_REQUEST	即能得到get的传值结果，也能得到Post传值的结果<br>

超全局的$_POST等这一系列的超全局变量（外部变量）在函数内部也是可以用的。没有本文开始处变量作用域的限制

> 其实我们所有声明的变量都放到了$GLOBALS这个数组下面

1.通过$GLOBLAS来读取外部变量

```
<?php
$one = 10;
function demo(){
   $two = 100;
   $result = $two + $GLOBALS['one'];
   return $result;
}
//你会发现结果变成了110
echo demo();
```

2.通过$GLOBLAS，在函数内修改外部变量

```
<?php
$hongniu = '我是一个兵，来自老百姓';
function test(){
   echo '执行了函数test<br />';
   //调用test()函数，将通过$GLOBALS['hongniu'],把$hongniu的值改变掉
   $GLOBALS['hongniu'] = '帮助别人很快乐';
}
test();
//发现是不是输出的值变了呀？
echo $hongniu;
```

3.通过$GLOBLAS，在函数内创建全局变量

```
<?php
function hello(){
   $GLOBALS['que'] = '提神喝茶更好哟';
   echo '你调了一下函数hello<br />';
}
hello();
echo $que;
```

了解

```
<?php
  $a = 10;
  $b = 100;
  function test(){
     global $a , $b;
     echo $a + $b;
  }
  // 结果是不是显示出来了？
  test();
```

PHP 有三种不同的变量作用域：

local（局部）
global（全局）
static（静态）

函数之外声明的变量拥有 Global 作用域，只能在函数以外进行访问。

函数内部声明的变量拥有 LOCAL 作用域，只能在函数内部进行访问。

> 注意：不可在global 后写 $变量 = 值。

### 八、自定义函数之 参数的引用

普通传值,传值以后,是不同的地址名称,指向不同的内存实体;

引用传值,传引用后,是不同的地址名称,但都指向同一个内存实体;改变其中一个,另外一个就也被改变;

```
<?php
$a = 10;
$b = &$a;
$a = 100;
echo $a.'---------'.$b;
// 100---------100
```

>函数的参数引用，也是这个意思，将形参和实参指向到同一个位置<br>如果形参在函数体内发生变化，那么实参的值也发生变化

```
<?php
$foo = 100;
// 注意：在$n前面加上了&符
function demo( &$n ){
       $n = 10;
       return $n + $n;
}
echo  demo($foo).'<br />';
// $foo的值变为了10
echo $foo;

20
10
```

实参为$foo，在调用demo的时候，让$foo和$n指向到了同一个存储区域，当$n的值发生变化的时候。那么$foo的值也发生变化

### 九、自定义函数之 递归函数

>递归函数，递归只是一个名字，而递归函数的规定：函数体内调用函数自己

递归在实际工作中主要是用在：文件和文件夹操作的时候有使用到

```
<?php

$num = 10;
A($num);

function A( $arg ){
   echo $arg;
   B($arg);
   echo '我们需要不断的努力，努力到上天都为我们感动';
   echo $arg.'<br />';
}
function B( $number ){
       echo $number;
       echo '俺是狗蛋，执行完了<br />';
}

1010俺是狗蛋，执行完了
我们需要不断的努力，努力到上天都为我们感动10
```

思维盲区：

    1.代码是从上到下执行的，所有代码没有exit等停止符，函数必须执行完
    2.如果函数从函数A跳至函数B后，必须把函数B执行完成再执行函数A余下的代码
    3.递归函数必须要能执行完有结束条件，不然函数就会限入死循环。函数会永远的自我执行下去

```
<?php

dg(2);

function dg( $n ){
   echo $n.'<br />';
   $n = $n - 1;
   if($n > 0){
       dg($n);
   }else{
       echo '--------------';
   }
   echo '俺是狗蛋，俺还没执行' . $n . '<br />';
}
```

仔细推理一次：

    1.第一次调用dg()，将数字$n = 2传到dg中，先显示出来了2
    2.然后将$n - 1 $n的值为了1
    3.接着判断$n 是否大于0,肯定是大于0的，所以调用递归自己，再把自己执行一次

    4.第二次在执行自己dg()的时候，最下面的 echo '俺是狗蛋，俺还没执行'.$n;还没有执行到,等待执行完成后再来执行

    5.$n此时等于1 ，所以显示出来1
    6.$n把自己减了一次，$n的结果为0
    7.$n大于0肯定不成立的，所以显示了一条:"--------------"
    8.而这个时候该执行：echo '俺是狗蛋，俺还没执行' . $n;

    9.第二次执行dg()执行完成。第一次dg()的代码还没执行完，将第4点中的余下代码执行完

### 十、自定义函数之 静态变量

>如果想知道函数被调用了多少次怎么办？在没有学习静态变量的时候，没有好的办法来解决<br>
>特点是：声明一个静态变量，第二次调用函数的时候，静态变量不会再初始化变量，会在原值的基础上读取执行<br>
>有了这个特点，我们就可以实现，最开始的提问：函数调用词数的统计

先执行5次demo()函数试试，再执行5次test()函数试试：

```
<?php

  function demo()
  {
     $a = 0;
     echo $a;
     $a++;
  }
  function test()
  {
     static $a = 0;
     echo $a;
     $a++;
  }

demo();
demo();
demo();
demo();
demo();

echo '<br />';
for($i = 0 ;$i < 5 ; $i++){
   test();
}

00000
01234
```

### 十一、php​ 使用系统 内置函数

> 手册...<br>
> http://www.php.cn （每周更新一次）

使用函数的重点是三块：

    1.了解函数的功能，特别是常用函数的功能
    2.了解函数的参数
    3.了解函数的返回值

函数的基本用法的全部注意事项

    1.直接返回布尔型，如bool copy ()
    2.带有MIXED参数的函数如何调用。Mixed表示任何类型的数据。如Array_unshift()
    3.参数中带有&符的参数，一定要传一个变量做为参数。函数里面改变了他的值
    4.带有[]的参数，表示可选项
    5.带有…的参数，表示可以传任意多个参数。
    6.带有callback的参数，表示回调函数。需要传一个函数进来。Array_map()
    7.函数支持的版本你要了解

>bool copy ( string $source , string $dest [, resource $context ] )

函数功能： 拷备一个文件<br>
返回值： bool型值，成功返true，失败返false<br>
参数： 两个字符串的值，一个是copy的源文件，一个为目标文件。第三个参数可选的，不常用不管它

>int array_unshift ( array &$array , mixed $value1 [, mixed $... ] )

功能： 操作一个数组，向数组中之`前`插入其他类型的参数<br>
返回值： int 类型，插入成功最后的个数<br>
参数：

第一个参数为&符，也就是在操作的过程中，改变了第一个参数的值。引用传参。也就是操作这个数组，向这个数组中传入参数。会直接改变这个数组的值<br>
第二个参数为mixed，因为数组可以存入多个不同的类型.mixed是指混合的意思。因此，mixed是指可传入任意类型<br>
第三个参数加了中括号，我们所有遇到中括号的。都是指后面的参数可传，也可以不传<br>
第四，最后还看到了三个...(省略号)。代表可以传入任意多个参数

```
<?php
  $queue = array("凤姐", "芙蓉");
  $sum = array_unshift($queue, "杨幂", "姚晨");
  print_r($queue);
  echo $sum;

Array ( [0] => 杨幂 [1] => 姚晨 [2] => 凤姐 [3] => 芙蓉 ) 4
```

遇到callback的传函数或者匿名函数进去协助处理，让功能更强大

>bool array_walk ( array &$array , callable $callback [, mixed $userdata = NULL ] )

功能：使用用户自定义函数对数组中的每个元素做回调处理

参数：第一个参数是要操作的数组<br>
第二个参数是callback 代表着可以传入函数或者匿名函数

```
<?php

$shuaige = array("a" => "wuyanzhu", "b" => "huangxiaoming", "c" => "zzz");

function test_print($item2, $key)
{
   echo $key ." ---". strtoupper($item2) . "<br />\n";
}

echo '<pre>';
var_dump($shuaige);
echo '</pre>';

array_walk($shuaige, 'test_print');

echo '用自定义函数test_print执行后的效果：';

echo '<pre>';
var_dump($shuaige);
echo '</pre>';

array(3) {
  ["a"]=>
  string(8) "wuyanzhu"
  ["b"]=>
  string(13) "huangxiaoming"
  ["c"]=>
  string(3) "zzz"
}
a ---WUYANZHU
b ---HUANGXIAOMING
c ---ZZZ
用自定义函数test_print执行后的效果：
array(3) {
  ["a"]=>
  string(8) "wuyanzhu"
  ["b"]=>
  string(13) "huangxiaoming"
  ["c"]=>
  string(3) "zzz"
}

小试1
$b = array_walk($shuaige, 'test_print');
var_dump($b);
// bool(true)

小试2
function test_print(&$item2)
{
    $item2 = 'abc:'.$item2;
}
改变了数组

小试3
array_walk($shuaige,function(&$val){
    $val = 'xxx:'.$val;
});
```

典型情况下 callback 接受两个参数。array 参数的值作为第一个，键名作为第二个

*有时为什么无法调用执行函数呢？请注意，可以 `phpinfo()` 看一下你当前的版本*

```
<?php

$fruits = array("d" => "lemon", "a" => "orange", "b" => "banana", "c" => "apple");

// 测试修改
function test_alter(&$item1, $key, $prefix)
{
    $item1 = "$prefix: $item1";
}
// 测试打印
function test_print($item2, $key)
{
    echo "$key. $item2<br />\n";
}

echo "Before ... :<br />";
array_walk($fruits, 'test_print');

array_walk($fruits, 'test_alter', 'fruit');
echo "... and after:<br />";

array_walk($fruits, 'test_print');

echo '<pre>';
var_dump($fruits);
echo '</pre>';

输出：
Before ... :
d. lemon
a. orange
b. banana
c. apple
... and after:
d. fruit: lemon
a. fruit: orange
b. fruit: banana
c. fruit: apple
array(4) {
  ["d"]=>
  string(12) "fruit: lemon"
  ["a"]=>
  string(13) "fruit: orange"
  ["b"]=>
  string(13) "fruit: banana"
  ["c"]=>
  string(12) "fruit: apple"
}
```
